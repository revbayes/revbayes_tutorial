
# modified from https://github.com/GuangchuangYu/ggtree/blob/master/R/tree-utilities.R
getXcoord2 <- function(x, root, parent, child, len, start=0, rev=FALSE) {
    x[root] <- start
    x[-root] <- NA  ## only root is set to start, by default 0

    currentNode <- root
    direction <- 1
    if (rev == TRUE) {
        direction <- -1
    }
    while(anyNA(x)) {
        idx <- which(parent %in% currentNode)
        newNode <- child[idx]
        x[newNode] <- x[parent[idx]]+len[idx] * direction
        currentNode <- newNode
    }

    return(x)
}

# modified from https://github.com/GuangchuangYu/ggtree/blob/master/R/tree-utilities.R
getXcoord <- function(tr) {
    edge <- tr$edge
    parent <- edge[,1]
    child <- edge[,2]
    root <- getRoot(tr)

    len <- tr$edge.length

    N <- getNodeNum(tr)
    x <- numeric(N)
    x <- getXcoord2(x, root, parent, child, len)
    return(x)
}

# modified from https://github.com/GuangchuangYu/ggtree/blob/master/R/tree-utilities.R
getYcoord <- function(tr, step=1) {
    Ntip <- length(tr[["tip.label"]])
    N <- getNodeNum(tr)

    edge <- tr[["edge"]]
    parent <- edge[,1]
    child <- edge[,2]

    cl <- split(child, parent)
    child_list <- list()
    child_list[as.numeric(names(cl))] <- cl

    y <- numeric(N)
    tip.idx <- child[child <= Ntip]
    y[tip.idx] <- 1:Ntip * step
    y[-tip.idx] <- NA

    currentNode <- 1:Ntip
    while(anyNA(y)) {
        pNode <- unique(parent[child %in% currentNode])
        ## piping of magrittr is slower than nested function call.
        ## pipeR is fastest, may consider to use pipeR
        ##
        ## child %in% currentNode %>% which %>% parent[.] %>% unique
        ## idx <- sapply(pNode, function(i) all(child[parent == i] %in% currentNode))
        idx <- sapply(pNode, function(i) all(child_list[[i]] %in% currentNode))
        newNode <- pNode[idx]

        y[newNode] <- sapply(newNode, function(i) {
            mean(y[child_list[[i]]], na.rm=TRUE)
            ##child[parent == i] %>% y[.] %>% mean(na.rm=TRUE)
        })

        currentNode <- c(currentNode[!currentNode %in% unlist(child_list[newNode])], newNode)
        ## currentNode <- c(currentNode[!currentNode %in% child[parent %in% newNode]], newNode)
        ## parent %in% newNode %>% child[.] %>%
        ##     `%in%`(currentNode, .) %>% `!` %>%
        ##         currentNode[.] %>% c(., newNode)
    }

    return(y)
}

# modified from https://github.com/GuangchuangYu/ggtree/blob/master/R/tree-utilities.R
getParent <- function(tr, node) {
    if ( node == getRoot(tr) )
        return(0)
    edge <- tr[["edge"]]
    parent <- edge[,1]
    child <- edge[,2]
    res <- parent[child == node]
    if (length(res) == 0) {
        stop("cannot found parent node...")
    }
    if (length(res) > 1) {
        stop("multiple parent found...")
    }
    return(res)
}

################################################################################
#
# @brief Function to plot ancestral states and the associated uncertainty
#        for continuous and discrete characters.
#
#        For discrete characters 'summary_statistic="MAP"' should be used,
#        and for continuous characters 'summary_statistic="mean"'. If the
#        tree and tip labels do not fit in the screen, adjust the visible
#        area using the 'xlim_visible' argument.
#
#        If 'summary_statistic="MAP"', the maximum a posteriori ancestral
#        state will be plotted on each node. The color corresponds to the
#        character state, and the size of the circle represents the posterior
#        probability of that state. Cladogenetic models that estimate 
#        ancestral states for both the beginning and end of each branch
#        are plotted by setting "include_start_states=TRUE".
#
#        Maximum a posteriori ancestral chromosome numbers can be plotted 
#        with 'summary_statistic="MAPChromosome"'. For chromosomes the
#        color represents the posterior probability and the size of the
#        circle represents the chromosome number.
#
#        For 'summary_statistic="mean"' the color represents the size of 
#        the 95% confidence interval, and the size of the cirlce represents
#        represents the mean character state.
#
# @date Last modified: 2016-09-29
# @author Will Freyman
# @version 1.0
# @since 2016-08-31, version 1.0.0
#
# @param    tree_file               character     Path to the ancestral state tree generated by RevBayes.
# @param    summary_statistic       character   The type of summary statistic to plot.
# @param    tree_layout             character   One of 'rectangular', 'slanted', 'fan', 'circular', 'radial', or 'unrooted'.
# @param    include_start_states    logical     Plot start and end ancestral states. Used for cladogenetic models.
#
#
################################################################################
plot_ancestral_states = function(tree_file, 
                                 summary_statistic="MAP", 
                                 tree_layout="rectangular",
                                 include_start_states=FALSE, 
                                 xlim_visible=c(0, 40), 
                                 ylim_visible=NULL,
                                 tip_label_size=4, 
                                 tip_label_offset=3,
                                 node_label_size=4, 
                                 node_label_hjust=-0.2, 
                                 shoulder_label_size=3, 
                                 shoulder_label_hjust=1.5, 
                                 alpha=0.5, 
                                 node_size_range=c(6, 15), 
                                 color_low="#D55E00",
                                 color_mid="#F0E442",
                                 color_high="#009E73") { 

    if ( (summary_statistic %in% c("MAP", "mean", "MAPChromosome")) == FALSE ) {
        print("Invalid summary statistic.")
        return()
    }

    # read in tree
    t = read.beast(tree_file)
    tree = attributes(t)$phylo
    n_node = getNodeNum(tree)

    # remove underscores from tip labels
    attributes(t)$phylo$tip.label = gsub("_", " ", attributes(t)$phylo$tip.label)

    # add tip labels
    p = ggtree(t, layout=tree_layout) 
    p = p + geom_tiplab(size=tip_label_size, offset=tip_label_offset)
       

    if (summary_statistic == "MAPChromosome") {
        
        if (include_start_states) {
            
            if (!("start_state_1" %in% colnames(attributes(t)$stats))) {
                print("Start states not found in input tree.")
                return()
            }

            # add ancestral states as node labels
            p = p + geom_text(aes(label=end_state_1), hjust=node_label_hjust, size=node_label_size)

            # set the root's start state to NA
            attributes(t)$stats$start_state_1[n_node] = NA

            # add clado daughter lineage start states on "shoulders" of tree
            # get x, y coordinates of all nodes
            x = getXcoord(tree)
            y = getYcoord(tree)
            x_anc = numeric(n_node)
            node_index = numeric(n_node)
            for (i in 1:n_node) {
                if (getParent(tree, i) != 0) {
                    # if not the root, get the x coordinate for the parent node
                    x_anc[i] = x[getParent(tree, i)]
                    node_index[i] = i
                }
            }
            shoulder_data = data.frame(node=node_index, x_anc=x_anc, y=y)
            p = p %<+% shoulder_data
            
            # plot the states on the "shoulders"
            p = p + geom_text(aes(label=start_state_1, x=x_anc, y=y), hjust=shoulder_label_hjust, size=shoulder_label_size, na.rm=TRUE)
            
            # show ancestral states as size / posteriors as color
            p = p + geom_nodepoint(aes(colour=end_state_1_pp, size=end_state_1), alpha=alpha)
            min_low = 0.0
            max_up = 1.0
            p = p + scale_colour_gradient2(low=color_low, mid=color_mid, high=color_high, limits=c(min_low, max_up), midpoint=0.5)
            p = p + guides(size = guide_legend("Chromosome Number"))
            p = p + guides(colour = guide_legend("Posterior Probability", override.aes = list(size=8)))

        } else {
    
            if (!("anc_state_1" %in% colnames(attributes(t)$stats))) {
                anc_data = data.frame(node=names(attributes(t)$stats$end_state_1), 
                                      anc_state_1=as.numeric(levels(attributes(t)$stats$end_state_1))[attributes(t)$stats$end_state_1],
                                      anc_state_1_pp=as.numeric(levels(attributes(t)$stats$end_state_1_pp))[attributes(t)$stats$end_state_1_pp])
                p = p %<+% anc_data
            }

            # add end states as node labels
            p = p + geom_text(aes(label=anc_state_1), hjust=node_label_hjust, size=node_label_size)

            # show ancestral states as size / posteriors as color
            p = p + geom_nodepoint(aes(colour=end_state_1_pp, size=end_state_1), alpha=alpha)
            min_low = 0.0
            max_up = 1.0
            p = p + scale_colour_gradient2(low=color_low, mid=color_mid, high=color_high, limits=c(min_low, max_up), midpoint=0.5)
            p = p + guides(size = guide_legend("Chromosome Number"))
            p = p + guides(colour = guide_legend("Posterior Probability", override.aes = list(size=8)))
        }

    } else if (summary_statistic == "MAP") {

        if (include_start_states) {
            print("Start states not yet implemented for MAP ancestral states.")
            return()
    
        }
        
        if (!("anc_state_1" %in% colnames(attributes(t)$stats))) {
            anc_data = data.frame(node=names(attributes(t)$stats$end_state_1), 
                                  anc_state_1=as.numeric(levels(attributes(t)$stats$end_state_1))[attributes(t)$stats$end_state_1],
                                  anc_state_1_pp=as.numeric(levels(attributes(t)$stats$end_state_1_pp))[attributes(t)$stats$end_state_1_pp])
            p = p %<+% anc_data
        }

        # add ancestral states as node labels
        p = p + geom_text(aes(label=anc_state_1), hjust=node_label_hjust, size=node_label_size)

        # show ancestral states as size / posteriors as color
        p = p + geom_nodepoint(aes(colour=anc_state_1_pp, size=anc_state_1), alpha=alpha)
        
        # show the tip values
        p = p + geom_tippoint(aes(size=anc_state_1), color="grey", alpha=alpha)
        
        # set up the legend
        min_low = 0.0
        max_up = 1.0
        p = p + scale_colour_gradient2(low=color_low, mid=color_mid, high=color_high, limits=c(min_low, max_up), midpoint=0.5)
        p = p + guides(size = guide_legend("State"))
        p = p + guides(colour = guide_legend("Posterior Probability", override.aes = list(size=4)))


    } else if (summary_statistic == "mean") {
    
        if (include_start_states) {
            print("Start states not implemented for mean ancestral states.")
            return()
        }

        # add ancestral states as node labels
        p = p + geom_text(aes(label=round(mean, 2)), hjust=node_label_hjust, size=node_label_size)

        # show the size of the 95% CI as color 
        lowers = as.numeric(levels(attributes(t)$stats$lower_0.95_CI))[attributes(t)$stats$lower_0.95_CI]
        uppers = as.numeric(levels(attributes(t)$stats$upper_0.95_CI))[attributes(t)$stats$upper_0.95_CI]
        diffs = uppers - lowers
        diffs_df = data.frame(node=names(attributes(t)$stats$lower_0.95_CI), diff_vals=diffs)
        p = p %<+% diffs_df 

        min_low = min(diffs, na.rm=TRUE)
        max_up = max(diffs, na.rm=TRUE)
        mid_val = min_low + (max_up - min_low) / 2.0
        p = p + scale_colour_gradient2(low=color_low, mid=color_mid, high=color_high, limits=c(min_low, max_up), midpoint=mid_val)
        p = p + geom_nodepoint(aes(size=mean, colour=diff_vals), alpha=alpha)

        # show the tip values
        p = p + geom_tippoint(aes(size=mean), color="grey", alpha=alpha)

        # set up the legend
        legend_text = "Mean State"
        p = p + guides(size = guide_legend(legend_text))
        p = p + guides(colour = guide_legend("95% CI Width", override.aes=list(size=4)))
        
    
    } 
    p = p + scale_size(range = node_size_range)
    p = p + theme(legend.position="left")

    # set visible area
    p = p + coord_cartesian(xlim = xlim_visible, ylim=ylim_visible, expand=TRUE)
    print(p)
    return(p)
}

